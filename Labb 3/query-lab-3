-- 1. Find the country with the fewest number of borders.
WITH CombinedBorders AS (
    SELECT
        c.Name AS country_name,
        b.Country2 AS border_country
    FROM
        Country c
    JOIN
        borders b ON c.Code = b.Country1
    UNION
    SELECT
        c.Name AS country_name,
        b.Country1 AS border_country
    FROM
        Country c
    JOIN
        borders b ON c.Code = b.Country2
),
BorderCounts AS (
    SELECT
        country_name,
        COUNT(DISTINCT border_country) AS border_count
    FROM
        CombinedBorders
    GROUP BY
        country_name
)
SELECT
    country_name,
    border_count
FROM
    BorderCounts
WHERE
    border_count = (SELECT MIN(border_count) FROM BorderCounts)
ORDER BY
    country_name ASC;



--Task 2
SELECT 
    -- Select the 'language' column from the 'spoken' table (s)
    s.language,

    -- Calculate the estimated number of speakers for each language
    -- Multiply the country's population by the percentage (converted to a fraction) of people who speak the language
    -- Sum this value across all countries for each language
    -- CAST the result to BIGINT to ensure it is an integer
    CAST(SUM(c.population * (s.percentage / 100.0)) AS BIGINT) AS numberspeaker
FROM 
    -- From the 'country' table (c) which contains country data, including population
    country c
JOIN 
    -- Join with the 'spoken' table
    spoken s 
ON 
-- Join condition: match the country code in 'country' table with the country code in 'spoken' table
    c.code = s.country
GROUP BY 
-- Group the results by language 
    s.language
HAVING 
-- Filter out languages with zero speakers
    SUM(c.population * (s.percentage / 100.0)) > 0
ORDER BY 
-- Order the results by the number of speakers, in descending order
    numberspeaker DESC;

--Task 3
WITH BorderCountryGdp AS(
    SELECT
        c.Code AS country1,                      -- Show country 1 code
        e1.GDP AS gdp1,                  -- Show GDP for country 1
        b.Country2 AS country2,                   -- Show the code of the bordering country (Country2)
        e2.GDP AS gdp2                    -- Show GDP for country 2
    FROM
        Country c
    JOIN
        borders b ON c.Code = b.Country1           -- Join with borders table on country 1
    JOIN
        economy e1 ON c.Code = e1.country         -- Join with economy table for country 1 GDP
    JOIN
        economy e2 ON b.Country2 = e2.country    -- Join with economy table for country 2 GDP
    WHERE 
        e1.gdp IS NOT NULL
        AND e2.gdp IS NOT NULL
)
SELECT 
    country1,
    gdp1,
    country2,
    gdp2,
    CAST((GREATEST(gdp1,gdp2) / LEAST(gdp1, gdp2) )AS BIGINT) AS ratio 
FROM
    BorderCountryGdp
ORDER BY ratio DESC;

-- P+

-- 1.
WITH RECURSIVE CombinedBorders AS (
    SELECT
        c.Code AS code,
        c.Name AS name,
        b.Country2 AS border_country
    FROM
        Country c
    JOIN
        borders b ON c.Code = b.Country1
    UNION
    SELECT
        c.Code AS code,
        c.Name AS name,
        b.Country1 AS border_country
    FROM
        Country c
    JOIN
        borders b ON c.Code = b.Country2
),
SwedenBordersFiveSteps AS (
    -- Base case: Find Sweden's immediate borders
    SELECT
        code,
        name,
        0 AS steps
    FROM
        CombinedBorders
    WHERE
        code = 'S'
    UNION ALL
    -- Recursive case: Find the next set of borders
    SELECT
        cb.code,
        cb.name,
        sbfs.steps + 1
    FROM
        SwedenBordersFiveSteps sbfs
    JOIN
        CombinedBorders cb ON sbfs.code = cb.border_country
    WHERE
        sbfs.steps < 5
), MinSteps AS (
    SELECT
        code,
        name,
        MIN(steps) AS min_steps
    FROM
        SwedenBordersFiveSteps
    GROUP BY
        code, name
)
SELECT
    code,
    name,
    min_steps AS steps
FROM
    MinSteps
WHERE
    code != 'S'
ORDER BY
    steps, code, name;

-- 2.
-- Recursive Common Table Expression (CTE) to trace river branch connections
WITH RECURSIVE RiverSystem AS (
    -- Initial selection of main rivers (base case for recursion)
    SELECT 
        Name,                   -- Current river name
        Name AS MainRiver,      -- Main river (parent river)
        Name AS Branch,         -- Current branch 
        ARRAY[Name]::VARCHAR[] AS RiverChain  -- Array to track river chain
    FROM River
    -- Limit to specific rivers for analysis
    WHERE Name IN ('Nile', 'Amazonas', 'Yangtze', 'Rhein', 'Donau', 'Mississippi')
    
    UNION
    
    -- Recursive part: Find connected branches for each river
    SELECT 
        rs.Name,                -- Keeps track of original main river
        rs.MainRiver,           -- Maintains the original main river name
        r.Name AS Branch,        -- New branch found through connection
        rs.RiverChain || r.Name  -- Append new branch to existing river chain
    FROM RiverSystem rs
    JOIN River r ON rs.Branch = r.River  -- Join to find connected branches
),

-- Calculate the number of rivers in each branch chain
BranchCounts AS (
    SELECT 
        MainRiver,               -- Main river name
        Branch,                  -- Branch river name
        array_length(RiverChain, 1) AS NumRivers,  -- Count of rivers in chain
        RiverChain               -- Full array of rivers in the chain
    FROM RiverSystem
),

-- Find the maximum number of rivers for each main river
LongestBranches AS (
    SELECT 
        MainRiver,
        MAX(NumRivers) AS MaxRivers  -- Longest branch chain for each main river
    FROM BranchCounts
    GROUP BY MainRiver
),

RankedBranches AS (
    SELECT 
        bc.MainRiver,
        array_to_string(bc.RiverChain, ' -> ') AS Path,
        bc.NumRivers,
        RANK() OVER (ORDER BY bc.NumRivers ASC) AS Rank,
        (
            SELECT SUM(r.Length)
            FROM unnest(bc.RiverChain) AS chain_river
            JOIN River r ON r.Name = chain_river
        ) AS TotalLength
    FROM BranchCounts bc
    JOIN LongestBranches lb 
        ON bc.MainRiver = lb.MainRiver AND bc.NumRivers = lb.MaxRivers
)
SELECT 
    Rank,
    Path,
    NumRivers,
    ROUND(TotalLength, 2) AS TotalLength
FROM RankedBranches
ORDER BY NumRivers ASC, TotalLength DESC;